{
  "name": "Spills",
  "tagline": "Disk-based sequences",
  "body": "# Spills\r\n\r\nSpills are sequences that spill to disk when they do not fit in memory. They\r\nare simply represented by a memory-mapped file, hence they are to be used with\r\ntype that are flat - that is, they are obtained by combining primitive types,\r\nobjects and arrays, but do not involve seqs, strings or references to heap\r\nmemory. In short, you should be able to compute their size statically.\r\n\r\nSpills work in two modes:\r\n\r\n* writable spills wrap a stream, and one can `add` to them, which just amounts\r\n  to writing to the stream;\r\n* normal spills are fixed-size. You can read and write their elements, iterate\r\n  over them and so on, but cannot grow.\r\n\r\nUsually, one first populates a writable spills, then obtains the corresponding\r\nspill from that, and works from there.\r\n\r\nAn example:\r\n\r\n```nim\r\nimport spills\r\n\r\ntype Foo = object\r\n  a, b: int\r\n  c: float\r\n\r\ninitSpills()\r\n\r\nvar x = writableSpill[Foo]()\r\nfor i in 0 .. 1000000:\r\n  x.add(Foo(a: i, b: i + 1, c: i.float))\r\nx.close()\r\n\r\nvar y = spill(x)\r\necho y\r\necho y[1234]\r\n\r\nvar z = y.map(proc(f: Foo): float = f.c)\r\n\r\necho z1[1234]\r\n\r\ny.close()\r\nz.close()\r\n```\r\n\r\n## Managing resources\r\n\r\nSince spills are associated to files, there are two concerns:\r\n\r\n* closing streams and other objects to make sure that changes to disk are\r\n  flushed and resources released\r\n* removing intermediate temporary files.\r\n\r\nSpills are written to a temporary directory by default. To set this directory\r\nand create it, call `initSpills(dir)`. Just calling `initSpills()` will use a\r\ndefault directory of `/tmp/spills`.\r\n\r\nEvery method that creates a new spill object optionally accepts a path parameter.\r\nIf this parameter is missing, files are created in the temporary directory.\r\nAt the end, you can call `destroySpills()` to remove the files generated in this\r\ndirectory. In this way, you can choose which files to persist across sessions,\r\nand which ones to remove.\r\n\r\nFinally, spills (both simple and writable) have a close method that will unmap\r\nthe file from memory (respectively, close the associated stream).\r\n\r\n## Sequence operations\r\n\r\nSpills admit a few standard sequence operations. Other than reading and writing\r\nsingle items, there are `map`, `filter`, `foldl` and `foldr`. These work as the\r\nsimilar operations in `sequtils`, except that `map` and `filter` optionally\r\ntake a path parameter.\r\n\r\nThere are also functions `toSpill[T](s: seq[T]): Spill[T]` and\r\n`toSeq[T](s: Spill[T]): seq[T]` to convert back and forth from sequences.\r\n\r\n## Strings\r\n\r\nStrings are variable-length, and as such cannot be stored into spills. Since\r\nthey are quite a common type, we provide a `VarChar[N]` type under `spills/varchar`.\r\n\r\n`VarChar[N]` is a wrapper over an array of `N` chars and a length field. If you\r\nknow beforehand that all your strings will not be longer than `N`, you can use\r\nit instead. One can convert back and forth using\r\n\r\n```nim\r\nimport spills/varchar\r\n\r\nlet\r\n  a = \"Hello, world\"\r\n  b = a.varchar(15)\r\n  c = $b\r\n\r\nassert a == c\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}